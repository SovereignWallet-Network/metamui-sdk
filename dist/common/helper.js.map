{"version":3,"sources":["../src/common/helper.ts"],"names":[],"mappings":";;;;;;;;;;;;AAIA,SAAS,iBAAiB,CAAC,QAA4D,EAAE,GAAc;IACnG,IAAI,SAAS,GAAO;QAChB,eAAe,EAAE,EAAE;QACnB,MAAM,EAAE,EAAE;KACb,CAAC;IACF,OAAO,IAAI,OAAO,CAAC,CAAO,OAAO,EAAE,MAAM,EAAE,EAAE;QACzC,MAAM,QAAQ,CAAC,IAAI,CAAC,UAAU,EAAE,MAAM,EAAE,MAAM,EAAE,aAAa,EAAE;YAC3D,IAAI,aAAa,EAAE;gBACf,IAAI,aAAa,CAAC,QAAQ,EAAE;oBACxB,yDAAyD;oBACzD,MAAM,OAAO,GAAG,GAAG,CAAC,QAAQ,CAAC,aAAa,CAAC,aAAa,CAAC,QAAQ,CAAC,CAAC;oBACnE,MAAM,EAAE,IAAI,EAAE,OAAO,EAAE,IAAI,EAAE,GAAG,OAAO,CAAC;oBACxC,OAAO,CAAC,GAAG,CAAC,GAAG,OAAO,IAAI,IAAI,KAAK,IAAI,CAAC,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,CAAC;oBACrD,MAAM,CAAC,IAAI,KAAK,CAAC,GAAG,OAAO,IAAI,IAAI,EAAE,CAAC,CAAC,CAAC;iBAC3C;qBAAM;oBACH,gDAAgD;oBAChD,MAAM,CAAC,IAAI,KAAK,CAAC,aAAa,CAAC,QAAQ,EAAE,CAAC,CAAC,CAAC;iBAC/C;aACJ;iBAAM,IAAI,MAAM,CAAC,WAAW,EAAE;gBAC3B,mEAAmE;gBACnE,MAAM,CAAC,OAAO,CAAC,CAAC,EAAE,KAAK,EAAE,KAAK,EAAE,EAAE,IAAI,EAAE,MAAM,EAAE,OAAO,EAAE,EAAE,EAAE,EAAE;oBAC3D,iFAAiF;oBACjF,IAAI,QAAQ,GAAO,EAAG,CAAC;oBACvB,QAAQ,CAAC,OAAO,CAAC,GAAG,EAAG,CAAC;oBACxB,QAAQ,CAAC,OAAO,CAAC,CAAC,MAAM,CAAC,GAAG,IAAI,CAAC,OAAO,EAAE,CAAC;oBAC3C,SAAS,CAAC,MAAM,mCAAO,SAAS,CAAC,MAAM,GAAK,QAAQ,CAAC,CAAC;gBAC1D,CAAC,CAAC,CAAC;gBACH,SAAS,CAAC,eAAe,GAAG,QAAQ,CAAC,IAAI,CAAC,KAAK,EAAE,CAAC;gBAClD,0BAA0B;gBAC1B,OAAO,CAAC,SAAS,CAAC,CAAC;aACtB;QACL,CAAC,CAAC,CAAC;IACP,CAAC,CAAA,CAAC,CAAC;AACP,CAAC;AAEQ,8CAAiB","file":"helper.js","sourcesContent":["import { ApiPromise } from \"@polkadot/api\";\nimport { SubmittableExtrinsic } from \"@polkadot/api/types\";\nimport { ISubmittableResult } from \"@polkadot/types/types\";\n\nfunction submitTransaction(signedTx:SubmittableExtrinsic<\"promise\", ISubmittableResult>, api:ApiPromise): Promise<any> {\n    let returnObj:any = {\n        transactionHash: \"\",\n        events: {},\n    };\n    return new Promise(async (resolve, reject) => {\n        await signedTx.send(function ({ status, events, dispatchError }) {\n            if (dispatchError) {\n                if (dispatchError.isModule) {\n                    // for module errors, we have the section indexed, lookup\n                    const decoded = api.registry.findMetaError(dispatchError.asModule);\n                    const { docs, section, name } = decoded;\n                    console.log(`${section}.${name}: ${docs.join(' ')}`);\n                    reject(new Error(`${section}.${name}`));\n                } else {\n                    // Other, CannotLookup, BadOrigin, no extra info\n                    reject(new Error(dispatchError.toString()));\n                }\n            } else if (status.isFinalized) {\n                // console.log('Finalized block hash', status.asFinalized.toHex());\n                events.forEach(({ phase, event: { data, method, section } }) => {\n                    // console.log('\\t', phase.toString(), `: ${section}.${method}`, data.toHuman());\n                    let eventObj:any = { };\n                    eventObj[section] = { };\n                    eventObj[section][method] = data.toHuman();\n                    returnObj.events = {...returnObj.events, ...eventObj};\n                });\n                returnObj.transactionHash = signedTx.hash.toHex();\n                // console.log(returnObj);\n                resolve(returnObj);\n            }\n        });\n    });\n}\n\nexport { submitTransaction };"]}